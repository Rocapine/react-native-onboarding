---
sidebar_position: 3
---

# Core Concepts

Understand how the Rocapine Onboarding Studio SDK works under the hood.

## Architecture Overview

The SDK is built with three main layers:

```
┌─────────────────────────────────────┐
│     Your React Native App          │
│  (Navigation, Routing, Business)   │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│      SDK Layer                      │
│  • OnboardingProvider               │
│  • useOnboardingQuestions           │
│  • OnboardingPage (Router)          │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│      CMS Backend                    │
│  (Supabase - Rocapine Studio)       │
└─────────────────────────────────────┘
```

## How It Works

### 1. Initialization

When you wrap your app with `OnboardingProvider`:

```typescript
<OnboardingProvider
  client={client}
  customAudienceParams={{ onboardingId: "abc-123" }}
>
```

The SDK:
1. Initializes React Query for data fetching
2. Sets up AsyncStorage caching
3. Prepares theme context
4. Establishes progress tracking

### 2. Data Fetching

When you call `useOnboardingQuestions({ stepNumber: 1 })`:

```typescript
const { step, isLastStep, totalSteps } = useOnboardingQuestions({ stepNumber: 1 });
```

The SDK:
1. Checks AsyncStorage cache first (offline support)
2. Fetches from CMS if cache is stale or missing
3. Uses React Query's `useSuspenseQuery` for automatic loading states
4. Validates data with Zod schemas
5. Updates progress context

### 3. Rendering

When you use `<OnboardingPage step={step} />`:

```typescript
<OnboardingPage step={step} onContinue={handleContinue} />
```

The SDK:
1. Inspects the `step.type` field
2. Routes to the appropriate renderer (`QuestionRenderer`, `MediaContentRenderer`, etc.)
3. Passes step data and callbacks
4. Handles fallback for unimplemented types (sandbox mode)

## Caching Strategy

### AsyncStorage Cache

The SDK uses AsyncStorage to cache onboarding steps for offline access:

```typescript
<OnboardingProvider
  cacheKey="my-app-onboarding" // Custom cache key
>
```

**Cache Behavior:**
- Steps are cached after successful fetch
- Cache is checked before network requests
- Stale data triggers background refresh
- Cache persists across app restarts

**Cache Invalidation:**
You can manually invalidate the cache:

```typescript
import { useQueryClient } from "@tanstack/react-query";

const queryClient = useQueryClient();
queryClient.invalidateQueries({ queryKey: ["onboardingSteps"] });
```

## Progress Tracking

The SDK automatically tracks progress through your onboarding flow:

### Progress Context

```typescript
const { activeStep, totalSteps, progress } = useContext(OnboardingProgressContext);
```

- `activeStep`: Current step number (updated by `useOnboardingQuestions`)
- `totalSteps`: Total number of steps in the flow
- `progress`: Percentage (0-1) of completion

### ProgressBar Component

The ProgressBar is **automatically included** in `OnboardingProvider` and integrates directly with expo-router:

```typescript
<OnboardingProvider {...props}>
  {/* Progress bar is automatic - no need to add it! */}
  <YourApp />
</OnboardingProvider>
```

The ProgressBar:
- **Automatic visibility**: Shows/hides based on `step.displayProgressHeader`
- **Auto back navigation**: Back button appears when `router.canGoBack()` returns true
- **Native integration**: Uses Reanimated for smooth 300ms animations
- **Smart positioning**: Positions at top of safe area automatically

**Control back navigation**: Use `router.push()` vs `router.replace()` in your step handlers to control when users can navigate back (see [Navigation Control](#navigation-control) below)

## Navigation Control

Control when users can navigate back by choosing the right routing method in your `onContinue` handlers.

### Router Methods

**`router.push(path)`** - Allows back navigation
- Adds route to navigation stack
- ProgressBar back button will appear on subsequent screens
- Use for normal step-by-step progression where users can review answers

**`router.replace(path)`** - Prevents back navigation
- Replaces current route in navigation stack
- ProgressBar back button will NOT appear (no history)
- Use when you don't want users returning to previous step

### Example: Standard Onboarding Flow

```typescript
// app/onboarding/[questionId].tsx
import {
  useOnboardingQuestions,
  OnboardingPage,
} from "@rocapine/react-native-onboarding-studio";
import { useLocalSearchParams, useRouter } from "expo-router";

export default function QuestionPage() {
  const { questionId } = useLocalSearchParams();
  const router = useRouter();

  const { step, isLastStep } = useOnboardingQuestions({
    stepNumber: parseInt(questionId as string, 10),
  });

  const onContinue = () => {
    if (isLastStep) {
      // Exit onboarding - prevent going back
      router.replace("/");
    } else {
      // Normal progression - allow back navigation
      router.push(`/onboarding/${parseInt(questionId as string, 10) + 1}`);
    }
  };

  return <OnboardingPage step={step} onContinue={onContinue} />;
}
```

### When to Use Each Method

✅ **Use `router.replace()` when:**
- Entering the first step (no previous step exists)
- After critical steps you don't want users to revisit
- Exiting onboarding to main app
- After irreversible actions (data submission, account creation)
- Preventing users from re-entering completed flows

✅ **Use `router.push()` when:**
- Normal step-by-step progression
- Users should review/change previous answers
- Building multi-step forms with editable data

### First Step Pattern

Prevent back button on the first onboarding step:

```typescript
// app/onboarding/index.tsx
export default function OnboardingStart() {
  const router = useRouter();

  const handleStart = () => {
    // Use replace - no back button will appear
    router.replace("/onboarding/1");
  };

  return <WelcomeScreen onStart={handleStart} />;
}
```

### Conditional Back Navigation

Disable back navigation for specific steps:

```typescript
const onContinue = () => {
  const nextStep = currentStep + 1;

  // Disable back navigation after payment step
  if (currentStep === PAYMENT_STEP) {
    router.replace(`/onboarding/${nextStep}`);
  } else {
    router.push(`/onboarding/${nextStep}`);
  }
};
```

:::tip
The ProgressBar automatically adapts to your routing choices - you don't need any additional configuration!
:::

## Step Types

Each step returned by the CMS has this structure:

```typescript
{
  id: string;                    // Unique identifier
  type: string;                  // "Question" | "MediaContent" | "Carousel" | ...
  name: string;                  // Display name (for debugging)
  displayProgressHeader: boolean; // Show/hide progress bar
  payload: object;               // Type-specific data
  customPayload: object | null;  // Your custom fields
  continueButtonLabel?: string;  // Optional CTA text
  figmaUrl?: string | null;      // Design reference
}
```

### Type Discrimination

The SDK uses the `type` field for routing:

```typescript
switch (step.type) {
  case "Question":
    return <QuestionRenderer step={step} onContinue={onContinue} />;
  case "MediaContent":
    return <MediaContentRenderer step={step} onContinue={onContinue} />;
  // ... more types
}
```

### Runtime Validation

All step data is validated at runtime using Zod schemas:

```typescript
const QuestionStepSchema = z.object({
  id: z.string(),
  type: z.literal("Question"),
  payload: z.object({
    title: z.string(),
    subtitle: z.string().nullish(),
    answers: z.array(/* ... */),
    // ...
  }),
  // ...
});
```

If data doesn't match the schema, you'll get a clear error message.

## Sandbox Mode

Enable sandbox mode during development:

```typescript
<OnboardingProvider isSandbox={true} />
```

**Sandbox Features:**
- Shows dev messages for unimplemented screen types
- More verbose error messages
- Allows testing without production CMS data
- Auto-continues on unimplemented screens

**Production Mode:**
- Silently auto-continues on unimplemented screens
- Minimal error messages
- Optimized for end-user experience

## Locale Support

Fetch onboarding content in different languages:

```typescript
<OnboardingProvider locale="fr" />
```

The locale is passed to the CMS API, which returns localized content based on your Rocapine Studio configuration.

## Custom Headers

The CMS API returns custom headers with metadata:

- `ONBS-Onboarding-Id`: The active onboarding ID
- `ONBS-Audience-Id`: The targeted audience
- `ONBS-Onboarding-Name`: Display name of the onboarding

These headers are available in the client but typically not needed in your app logic.

## Suspense Boundaries

The SDK uses React Query's `useSuspenseQuery`, which requires Suspense boundaries:

```typescript
import { Suspense } from "react";

<Suspense fallback={<LoadingScreen />}>
  <OnboardingScreen />
</Suspense>
```

:::tip
Expo Router handles Suspense automatically, so you usually don't need to add boundaries manually.
:::

## Error Handling

The SDK provides multiple layers of error handling:

1. **Network Errors**: Automatic retry with exponential backoff
2. **Validation Errors**: Clear messages about schema mismatches
3. **Missing Dependencies**: Explicit instructions for required packages
4. **Sandbox Mode**: Development-friendly error messages

## Theme System

The SDK provides a theme system with:
- **Color Tokens**: Semantic color names (primary, neutral, text, etc.)
- **Typography Tokens**: Font families, sizes, weights, line heights
- **Semantic Text Styles**: Pre-configured styles (heading1, body, button, etc.)
- **Mode Support**: Light and dark mode with separate token sets

Learn more in [Customization → Theming](./customization/theming.mdx).

## Performance Considerations

### Optimizations

- **Lazy Loading**: Renderers are lazy-loaded per screen type
- **Native Driver**: Animations use native driver when possible
- **Memoization**: Components are memoized where appropriate
- **Query Deduplication**: React Query prevents duplicate requests

### Best Practices

- Use pagination for long onboarding flows
- Preload media assets when possible
- Keep payload sizes reasonable
- Cache static assets locally

## Next Steps

- 📘 Explore the [API Reference](./api-reference.mdx) for detailed prop documentation
- 🎨 Learn about [Customization Options](./customization/intro.mdx)
- 🎭 Review available [Page Types](./page-types.mdx)
